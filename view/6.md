# 内部指令

## v-show && v-if
v-show: DOM 已经加载，v-show 判断是否显示
v-if: 判断是否加载 DOM

## v-html && v-text
当我们网速很慢或者javascript出错时，会暴露我们的{{xxx}}
使用 v-text
`<span>{{ message }}</span>  => <span v-text="message"></span>`

## v-on
`@click` 
    v-on:click.prevent.self 会阻止所有的点击
    v-on:click.self.prevent 只会阻止对元素自身的点击
`@keyup` 
    `.enter`/`.13`/`.up`/
`.passive`
```html
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```
`.native`   `.prevent`  `.stop`

## v-model
修饰符：
    `v-model.lazy=""`   可以取消 input 的 change 监听
    `.number`
    `.trim`

## v-bind
`:class="{}" `     `:class="[]" `     `:class="三元运算符" `
`:style="" `

# 全局 API

## directive 自定义指令
```js
Vue.directive('jspang',function(el,binding,vnode){
        el.style='color:'+binding.value;
});
```

## Vue.set 全局操作
Vue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法
```js
 function add(){
       Vue.set(outData,'count',4);
 }
```

## 绑定构造器里的原生事件
<p>< <btn @click.native="add(3)"></btn></p>

## mixins
> 为组件定义可复用的方法可以理解为一个父类，提供给子类继承，可以使用或是重写父类 的方法

写在构造器外
```js
var addControl = {
    updated() {
        alert('数据发生变化，：' + this.num)
    }
}

var app = new Vue({
    mixins: [addControl]
})
```

# 实例方法
## $mounted
挂载扩展 extends
`vm.$mounted('#app)`
## $destory
卸载方法
## $nextTick


# React
## 生命周期
1. componentWillMount() 
组件挂载前调用一次
2. componentDidMount()
组件挂载后调用一次 可以使用 refs
3. componentWillReceiveProps()
父组件发生render的时候子组件就会调用componentWillReceiveProps
4. componentWillUpdate()
5. componentDidUpdate()
每次渲染更新后调用
6. componentWillUnmount()
组件被卸载后调用

## 虚拟 DOM
类似 react 的 mvvm 封装了 DOM 层, DOM 操作太耗性能
react 就是通过 虚拟 DOM + diff 算法来实现 数据的热更新

什么是虚拟 DOM ？ 可以从 jsx 来得到一段虚拟 DOM，jsx 语法看似 是 将标记和js语言混合使用，但实质是 原生js，
我们通过 babel 将 jsx 编译成js 认识 的，结果就是一个 json 对象，
这个js 对象拥有三个参数，
一是 标签 tag，
二是 属性 attributes ，以对象的键值对形式，
三是 子节点，如果没有子节点，将返回一个文本节点，如果有，则返回子节点的递归数组
而这个js对象就是 虚拟DOM

**react的实现过程就是**使用 babel 将 `jsx ` 预编译成 `虚拟DOM`，然后 createElement 将虚拟节点传给 render() 方法，将虚拟 DOM 转为 真实DOM 渲染到页面上


使用虚拟DOM 减少真实 DOM 操作
因为 DOM操作是很消耗性能的
整个组件的更新往往会触发 重绘
而虚拟DOM 是在内存中计算 的

setState将返回一个新的 DOM，与旧 DOM进行对比

diff 算法
虚拟DOM 和真实 DOM 都是树形结构
diff 算法将两颗 DOM 树进行 逐层比较

只将改变的数据进行修改


# Koa

# nodejs
path
文件系统


把关系数据库的表结构映射到对象上
> Node 的 ORM 框架 Sequelize, 读写的都是 JavaScript 对象

# Vue 响应式原理
MVVM ：Model View ViewModel
Model 作为普通对象，修改 Model 则更新 view 

**vue的数据响应式实现主要分成2个部分：**

1. 把数据转化为getter和setter
2. 建立watcher并收集依赖

vue 中，将 一个普通对象传给 vue 实例作为 data，
vue.js 将 遍历它的属性
用 `Object.defineProperty` **转为 getter/setter** 
> (Object.defineProperty作为 ES5 的特性，不支持 IE8以下， 这便是为什么 Vue.js 不支持 IE8 及更低版本。)

给每个指令和数据绑定建立一个 watcher ，在计算过程中，watcher 把属性记录为 依赖 dep，
之后当属性，也就是依赖 dep 的 setter方法被调用时 ，watcher 会重新计算
也就会导致它的 关联指令更新 DOM


## 计算属性
计算属性追踪依赖，在计算计算属性时 ，**vue 更新它的依赖并缓存结果**
只有当 **依赖发生变化，缓存结果才无效**
**依赖不变**，访问计算属性会直接返回 **缓存**的结果

## MVC & MVVM
MVC：
`Model` 层用于封装和应用程序的 **业务逻辑相关的数据**以及对 **数据的处理方法**
`View` 作为视图层，主要负责数据的展示
对 `View` 的操作交给了 `Controller` 处理
`Controller` 调用 `Model` 的接口对数据进行操作，响应 `View` 更新

MVVM：
`Model` 称为数据层，因为它仅仅关注数据本身，不关心任何行为
`View` 通过使用 **模板语法**(挖个坑，放个变量 `{{}}` )来声明式的将 **数据渲染进DOM**
`ViewModel` 数据绑定，无需为 `model` 层提供可处理的接口
当 `Model` 发生变化，`ViewModel`就会自动更新；`ViewModel` 变化，`Model` 也会更新。

## 数据绑定
Vue: 数据劫持 Object.defineProperty、Proxy
大致分为三个模块：
- Observer：数据监听（数据劫持）发生变化后通知订阅者
- Compile：扫描模板、解析指令、 绑定事件
- Watcher：关联 Observer 和 Compile ，能够订阅并收到属性变动的通知，执行指令绑定的相应操作，更新视图
观察订阅者
angular: 脏值检查


## 单向数据流
单向数据流指只能从一个方向来修改状态，比如 父子组件，子组件修改状态后，父组件并不会

## vuex 单向数据流
多个组件会共享状态时，共享状态和组件间（兄弟组件）通信变的不容易。
我们把 **共享状态抽取**出来，用单向数据流的方式会变得容易。

组件中触发 Action，Action 提交 Mutations，Mutations 修改 State。 组件根据 State 或 Getters 来渲染页面